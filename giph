#!/bin/bash

readonly VERSION=0.1
stty -echoctl

function version() {
    printf "capture version: $VERSION \n"
}

function usage() {
    cat << EOF

SYNOPSIS
    capture [OPTIONS] [FILEPATH]

DESCRIPTION
    capture is an utility that records a selected area of your desktop,
    and converts it into a high quality animated gif file. By default
    it outputs the animated gif image data directly to standard output.

OPTIONS
    -h, --help
        Print help and exit.

    -v, --version
        Print version and exit.

    -s, --select
        Enables an interactive selection mode where you can select the
        desired region or window before the recording is started. This
        uses the "SLOP OPTIONS" described below.

    -w, --window=INT
        Sets the desired window to capture, defaults to the root window.
    
    -g, --geometry=GEOMETRY
        Sets the region to capture, uses local coordinates from the given window.
        So -g10x30-5+0 would represent the rectangle wxh+x+y where w=10, h=30, x=-5 and y=0.
        x and y are the upper left location of this rectangle.
    
    -q, --quality=INT[1-100]
        An integer from 1 to 100 that determines the final gif quality,
        where 1 is the lowest and 100 is the best quality.
    
    -d, --delay=INT
        Sets the time in seconds to wait before the recording starts.
        By default this prints a countdown to show how many seconds are left. 
    
    -f, --framerate=INT (default=10)
        Sets the desired framerate of the recorded gif.
        A higher framerate will result in a greater filesize.

SLOP OPTIONS
    -h, --highlight
        Instead of outlining the selection, it will be highlighted.
        This is only useful when --color is set to a transparent color.

    -c, --color=FLOAT,FLOAT,FLOAT,FLOAT
        Set a color for the selection. Supports RGB or RGBA values.
    
    -p, --padding=FLOAT (default=0)
        Set the padding size of the selection. Can be negative.
    
    -b, --bordersize=FLOAT (default=1)
        Set the selection rectange's thickness.

EOF
}

# clear last line
CLL='\033[0m\r'

# regular, bold, underlined, background, intense, bold intense and background intense colors
BLACK='\033[0;30m';RED='\033[0;31m';GREEN='\033[0;32m';YELLOW='\033[0;33m';BLUE='\033[0;34m';PURPLE='\033[0;35m';CYAN='\033[0;36m';WHITE='\033[0;37m';
BBLACK='\033[1;30m';BRED='\033[1;31m';BGREEN='\033[1;32m';BYELLOW='\033[1;33m';BBLUE='\033[1;34m';BPURPLE='\033[1;35m';BCYAN='\033[1;36m';BWHITE='\033[1;37m';
UBLACK='\033[4;30m';URED='\033[4;31m';UGREEN='\033[4;32m';UYELLOW='\033[4;33m';UBLUE='\033[4;34m';UPURPLE='\033[4;35m';UCYAN='\033[4;36m';UWHITE='\033[4;37m';
ON_BLACK='\033[40m';ON_RED='\033[41m';ON_GREEN='\033[42m';ON_YELLOW='\033[43m';ON_BLUE='\033[44m';ON_PURPLE='\033[45m';ON_CYAN='\033[46m';ON_WHITE='\033[47m';
IBLACK='\033[0;90m';IRED='\033[0;91m';IGREEN='\033[0;92m';IYELLOW='\033[0;93m';IBLUE='\033[0;94m';IPURPLE='\033[0;95m';ICYAN='\033[0;96m';IWHITE='\033[0;97m';
BIBLACK='\033[1;90m';BIRED='\033[1;91m';BIGREEN='\033[1;92m';BIYELLOW='\033[1;93m';BIBLUE='\033[1;94m';BIPURPLE='\033[1;95m';BICYAN='\033[1;96m';BIWHITE='\033[1;97m';
ON_IBLACK='\033[0;100m';ON_IRED='\033[0;101m';ON_IGREEN='\033[0;102m';ON_IYELLOW='\033[0;103m';ON_IBLUE='\033[0;104m';ON_IPURPLE='\033[0;105m';ON_ICYAN='\033[0;106m';ON_IWHITE='\033[0;107m'

# color reset
CR='\033[0m'

# log a message - (message:string, timestamp:bool, critical:bool, stay:bool)
function log() {
  log=(echo -e)

  if [ "$4" = true ]; then
    log+=(-n)
  fi

  if [ "$2" = true ]; then
    log+=("${WHITE}$(date '+%Y-%m-%d %H:%M:%S'):${CR}")
  fi

  log+=("$1")

  #${log[@]}

  if [ "$3" = true ]; then
    exit 1;
  fi
}

function log_error() {
  log "${BIBLACK}${ON_RED} $1 ${CR}" true true
}

function log_warning() {
  log "${BLACK}${ON_YELLOW} $1 ${CR}" true
}

function log_success() {
  log "${GREEN}$1${CR}" true
}

function log_info() {
  log "${CYAN}$1${CR}" true
}

# options
VERBOSE=0
SLOP=0
QUALITY=50
DELAY=0
FRAMERATE=10

# slop options
SLOP_HIGHLIGHT=0
SLOP_COLOR=0
SLOP_PADDING=0
SLOP_BORDERSIZE=0

# flag handling
while [[ "$1" == -* ]]; do
  case "$1" in
  -v*)
    (( VERBOSE += ${#1} - 1 ))
    ;;
  --verbose)
    (( VERBOSE++ ))
    ;;
  -h|--help)
    usage
    exit 0
    ;;
  --version)
    version
    exit 0
    ;;
  -s|--select)
    SLOP=1
    ;;
  -q|--quality)
    shift
    QUALITY="$1"
    ;;
  -d|--delay)
    shift
    DELAY="$1"
    ;;
  -f|--framerate)
    shift
    FRAMERATE="$1"
    ;;
  -l|--highlight)
    SLOP_HIGHLIGHT=1
    ;;
  -c|--color)
    shift
    SLOP_COLOR="$1"
    ;;
  -p|--padding)
    shift
    SLOP_PADDING="$1"
    ;;
  -b|--bordersize)
    shift
    SLOP_BORDERSIZE="$1"
    ;;
  --)
    shift
    break
    ;;
  esac
  shift
done

# additional option handling
if [ -n "$1" ]; then
    OUTPUT_FILE=$1
fi

function countdown() {
  seconds=$2
  while [ $seconds -ge 0 ]; do

    if [ $seconds -gt 0 ]; then
      log "$1 $seconds ${CLL}" false false true
      sleep 1
    else
      log "$1 $seconds"
    fi
    
    : $((seconds--))
  done
}

# launch slop to get geometry information
function get_slop_geometry() {
  slop=(slop -f "%x %y %w %h %g %i")

  if [ $SLOP_HIGHLIGHT = 1 ]; then
      slop+=(-l)
  fi

  if [ $SLOP_BORDERSIZE != 0 ]; then
    slop+=(-b $SLOP_BORDERSIZE)
  fi

  if [ $SLOP_PADDING != 0 ]; then
    slop+=(-p $SLOP_PADDING)
  fi

  if [ $SLOP_COLOR != 0 ]; then
    slop+=(-c $SLOP_COLOR)
  fi

  slop_value=$("${slop[@]}")

  if [ "$?" -eq 1 ]; then
    log_error "slop selection got canceled"
  fi

  read -r x_offset y_offset width height geometry_string window_id <<< $slop_value
}

function get_static_geometry() {
  printf ""
}

function log_geometry() {
  printf "using the following geometry:\n"
  printf "x_offset - $x_offset\n"
  printf "y-offset - $y_offset\n"
  printf "width - $width\n"
  printf "height - $height\n"
  printf "geometry string - $geometry_string\n"
  printf "window id - $window_id\n"
}

function create_temp_directory() {
  TEMP_DIRECTORY=$(mktemp -d --suffix=_capture)
  log "created temporary directory $TEMP_DIRECTORY" true
}

function record() {
  ffmpeg=(ffmpeg)
  ffmpeg+=(-f x11grab)
  ffmpeg+=(-framerate $FRAMERATE)
  ffmpeg+=(-s "$width"x"$height")
  ffmpeg+=(-i :0.0+$x_offset,$y_offset)
  ffmpeg+=(-loglevel "quiet")
  ffmpeg+=("$TEMP_DIRECTORY/recording.webm")

  # <- start test

  #${ffmpeg[@]} &
  #FFMPEG_PID=$!





  #wait

  #exit
  # <- end test
  #trap '' 2
  trap stop_recording INT

  if [ "$DELAY" -gt 0 ]; then
    countdown "${CYAN}recording starts in:${CR} " $DELAY
  fi

  ${ffmpeg[@]} &
  log "started ffmpeg recording" true
  log_info "stop recording with ${BLACK}${ON_CYAN} ctrl+c ${CR} or send INT SIGNAL to this process ${BLACK}${ON_CYAN} killall -int -g capture ${CR}"
  FFMPEG_PID=$!
}

function stop_recording() {
  #log "recording stopped, waiting for ffmpeg to exit" true
  wait $FFMPEG_PID
  log "ffmpeg exited successfully" true
  separate_frames
  compose_gif
}

function separate_frames() {
  log "separating video frames into individual images" true
  ffmpeg -loglevel "quiet" -i "$TEMP_DIRECTORY/recording.webm" "$TEMP_DIRECTORY/frame%04d.png"
}

function compose_gif() {
  log "composing final gif from separated frames" true

  gifski=(gifski --quiet)
  gifski+=(--quality $QUALITY)
  gifski+=(--fps $FRAMERATE)
  
  if [ -n "$OUTPUT_FILE" ]; then
    gifski+=(-o "$OUTPUT_FILE")
  else
    gifski+=(-o "$TEMP_DIRECTORY/final.gif")
  fi

  gifski+=($TEMP_DIRECTORY/frame*.png)

  "${gifski[@]}"

  if [ -z "$OUTPUT_FILE" ]; then
    cat "$TEMP_DIRECTORY/final.gif"
  fi
}


function start_capture() {
  if [ $SLOP = 1 ]; then
    log "using slop to select rectangle or window" true
    get_slop_geometry
  else
    get_static_geometry
  fi

  #log_geometry

  create_temp_directory

  record


}


start_capture
wait